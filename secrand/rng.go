package secrand

import (
	crypto_rand "crypto/rand"
	"fmt"
	"io"
	"sync"

	"github.com/aead/chacha20/chacha"
)

const (
	DefaultBufSize = 1024
	DefaultRounds  = 12
)

var (
	_masterRNG     = NewRNGFromReader(crypto_rand.Reader)
	_masterRNGLock sync.Mutex

	_defaultNonce = genDefaultNonce()
)

func mustRead(r io.Reader, b []byte) {
	n, err := io.ReadFull(r, b)
	if err != nil || n != len(b) {
		panic(fmt.Sprint("error reading random source: ", err))
	}
}

func genDefaultNonce() [chacha.NonceSize]byte {
	var nonce [chacha.NonceSize]byte
	mustRead(crypto_rand.Reader, nonce[:])
	return nonce
}

// An RNG is a cryptographically-strong RNG constructed from the ChaCha stream
// cipher.
type RNG struct {
	buf    []byte
	n      int
	rounds int
	nonce  [chacha.NonceSize]byte
}

func NewRNGFromSeed(seed [chacha.KeySize]byte) *RNG {
	return NewRNGCustom(seed, _defaultNonce, DefaultBufSize, DefaultRounds)
}

func NewRNGFromSeedNonce(seed [chacha.KeySize]byte, nonce [chacha.NonceSize]byte) *RNG {
	return NewRNGCustom(seed, nonce, DefaultBufSize, DefaultRounds)
}

func NewRNGFromReader(r io.Reader) *RNG {
	var seed [chacha.KeySize]byte
	mustRead(r, seed[:])
	return NewRNGFromSeed(seed)
}

// NewRNG returns a new RNG instance. The instance is seeded with entropy from
// crypto/rand, albeit indirectly; its seed is generated by a global "master"
// RNG, which itself is seeded from crypto/rand. This means the frand package
// only reads system entropy once, at startup.
func NewRNG() *RNG {
	_masterRNGLock.Lock()
	defer _masterRNGLock.Unlock()

	var seed [chacha.KeySize]byte
	_, _ = _masterRNG.Read(seed[:])
	return NewRNGFromSeed(seed)
}

// NewRNGCustom returns a new RNG instance seeded with the provided entropy and
// using the specified buffer size and number of ChaCha rounds. It panics if
// bufsize < 32 or or rounds != 8, 12 or 20.
func NewRNGCustom(seed [chacha.KeySize]byte, nonce [chacha.NonceSize]byte, bufsize int, rounds int) *RNG {
	if bufsize < chacha.KeySize*2 {
		panic("frand: bufsize must be at least 64")
	} else if !(rounds == 8 || rounds == 12 || rounds == 20) {
		panic("frand: rounds must be 8, 12, or 20")
	}
	buf := make([]byte, chacha.KeySize+bufsize)
	chacha.XORKeyStream(buf, buf, nonce[:], seed[:], rounds)
	return &RNG{
		buf:    buf,
		n:      chacha.KeySize,
		rounds: rounds,
		nonce:  nonce,
	}
}

// Read fills b with random data. It always returns len(b), nil.
//
// For performance reasons, calling Read once on a "large" buffer (larger than
// the RNG's internal buffer) will produce different output than calling Read
// multiple times on smaller buffers. If deterministic output is required,
// clients should call Read in a loop; when copying to an io.Writer, use
// io.CopyBuffer instead of io.Copy. Callers should also be aware that b is
// xored with random data, not directly overwritten; this means that the new
// contents of b depend on its previous contents.
func (r *RNG) Read(b []byte) (int, error) {
	if len(b) <= len(r.buf[r.n:]) {
		// can fill b entirely from buffer
		r.n += copyAndErase(b, r.buf[r.n:])
	} else if len(b) <= len(r.buf[r.n:])+len(r.buf[chacha.KeySize:]) {
		// b is larger than current buffer, but can be filled after a reseed
		n := copy(b, r.buf[r.n:])
		chacha.XORKeyStream(r.buf, r.buf, r.nonce[:], r.buf[:chacha.KeySize], r.rounds)
		r.n = chacha.KeySize + copyAndErase(b[n:], r.buf[chacha.KeySize:])
	} else {
		// filling b would require multiple reseeds; instead, generate a
		// temporary key, then write directly into b using that key
		var tmpKey [chacha.KeySize]byte
		_, _ = r.Read(tmpKey[:])
		chacha.XORKeyStream(b, b, r.nonce[:], tmpKey[:], r.rounds)
		erase(tmpKey[:])
	}
	return len(b), nil
}

func (r *RNG) Int63() int64 {
	return int64(r.Uint64() & ^uint64(1<<63))
}

func (r *RNG) Seed(seed int64) {
	panic("secrand.RNG.Seed is not supported")
}

func toUint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}

func (r *RNG) Uint64() uint64 {
	if 8 <= len(r.buf[r.n:]) {
		b := r.buf[r.n : r.n+8]
		v := toUint64(b)
		erase(b)
		r.n += 8
		return v
	}
	var b [8]byte
	_, _ = r.Read(b[:])
	return toUint64(b[:])
}

func erase(b []byte) {
	// compiles to memclr
	for i := range b {
		b[i] = 0
	}
}

func copyAndErase(dst, src []byte) int {
	n := copy(dst, src)
	erase(src[:n])
	return n
}
